using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Aspect.Generator
{
	[Generator(LanguageNames.CSharp)]
	public class AspectGenerator : IIncrementalGenerator
	{
		const string AspectAttributeText =
			"""
			// <auto-generated/>
			#pragma warning disable

			using System;

			namespace Aspects
			{
				[Aspect]
				[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
				sealed class AspectAttribute : Attribute
				{
					public string? OnInit       { get; set; }
					public string? OnUsing      { get; set; }
					public string? OnBeforeCall { get; set; }
					public string? OnAfterCall  { get; set; }
					public string? OnCatch      { get; set; }
					public string? OnFinally    { get; set; }
				}

				enum InterceptType
				{
					OnInit,
					OnBeforeCall,
					OnAfterCall,
					OnCatch,
					OnFinally
				}

				enum InterceptResult
				{
					Continue,
					Return,
					ReThrow = Continue
				}

				struct Void
				{
				}

				class InterceptCallInfo
				{
					public object?         Tag;
					public InterceptType   InterceptType;
					public InterceptResult InterceptResult;
					public Exception?      Exception;

					public InterceptCallInfo?                                    PreviousInfo;
					public System.Reflection.MemberInfo                          MemberInfo;
					public Type                                                  AspectType;
					public System.Collections.Generic.Dictionary<string,object?> AspectArguments;
				}

				class InterceptCallInfo<T> : InterceptCallInfo
				{
					public T ReturnValue;
				}
			}

			namespace System.Runtime.CompilerServices
			{
				[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
				sealed class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute
				{
				}
			}
			""";

		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
#if TRUE1
			if (!Debugger.IsAttached)
			{
				Debugger.Launch();
			}
#endif
			context.RegisterPostInitializationOutput(ctx => ctx.AddSource("AspectAttribute.g.cs", AspectAttributeText));

			var attributes = context.SyntaxProvider
				.ForAttributeWithMetadataName("Aspects.AspectAttribute",
					predicate: static (node, _) => node is ClassDeclarationSyntax,
					transform: static (attr, _) => attr)
				.Collect();

			context.RegisterImplementationSourceOutput(context.CompilationProvider.Combine(attributes), Implement);
		}

		static void Implement(SourceProductionContext spc, (Compilation Left, ImmutableArray<GeneratorAttributeSyntaxContext> Right) data)
		{
			var compilation = data.Left;
			var attrs       = data.Right;

			if (attrs.Length == 0)
				return;

			var aspectAttributes = attrs.Select(a => a.TargetSymbol).ToImmutableHashSet(SymbolEqualityComparer.Default);
			var aspectedMethods  = new List<(InvocationExpressionSyntax inv,IMethodSymbol method,ImmutableArray<AttributeData> attributes)>();

			foreach (var tree in compilation.SyntaxTrees)
			{
				var semantic = compilation.GetSemanticModel(tree);

				// Scan the semantic tree...
				//
				foreach (var node in tree.GetRoot(spc.CancellationToken).DescendantNodes())
				{
					// .. to find an invocation...
					//
					if (node.IsKind(SyntaxKind.InvocationExpression))
					{
						var info = semantic.GetSymbolInfo(node, spc.CancellationToken);

						// .. of a method...
						//
						if (info.Symbol is IMethodSymbol method)
						{
							var methodAttributes = method.GetAttributes();

							// .. decorated with any Aspect attribute.
							//
							if (methodAttributes.Any(a => aspectAttributes.Contains(a.AttributeClass!)))
								aspectedMethods.Add(((InvocationExpressionSyntax)node, method, methodAttributes));
						}
					}

					if (spc.CancellationToken.IsCancellationRequested)
						break;
				}

				if (spc.CancellationToken.IsCancellationRequested)
					break;
			}

			if (aspectedMethods.Count == 0 || spc.CancellationToken.IsCancellationRequested)
				return;

			GenerateSource(spc, aspectedMethods);
		}

		static void GenerateSource(SourceProductionContext spc, List<(InvocationExpressionSyntax inv,IMethodSymbol method,ImmutableArray<AttributeData> attributes)> aspectedMethods)
		{
			// Generate source. One file for all the interceptors.
			// Interceptors.g.cs
			//
			var sb = new StringBuilder(
				"""
				// <auto-generated/>
				#pragma warning disable
				#nullable enable

				using System;

				using SR  = System.Reflection;
				using SLE = System.Linq.Expressions;
				using SCG = System.Collections.Generic;

				namespace Aspects
				{
					static partial class Interceptors
					{
						static SR.MethodInfo GetMethodInfo(SLE.Expression expr)
						{
							return expr switch
							{
								SLE.MethodCallExpression mc => mc.Method,
								_                           => throw new InvalidOperationException()
							};
						}

						static SR.MethodInfo MethodOf<T>(SLE.Expression<Func<T>> func) => GetMethodInfo(func.Body);
						static SR.MethodInfo MethodOf   (SLE.Expression<Action>  func) => GetMethodInfo(func.Body);


				""");

			var nameCounter = 0;
			var nameSet     = new HashSet<string>();

			string GetInterceptorName(string methodName)
			{
				if (nameSet.Contains(methodName))
					return GetInterceptorName($"{methodName}_{++nameCounter}");

				nameSet.Add(methodName);
				return methodName;
			}

			foreach (var m in aspectedMethods.GroupBy(m => m.method, SymbolEqualityComparer.Default).OrderBy(m => m.Key!.Name))
			{
				var method          = (IMethodSymbol)m.Key!;
				var interceptorName = GetInterceptorName($"{method.Name}_Interceptor");
				var methods         = m.ToList();

				sb.AppendLine(
					$$"""
							static SR. MemberInfo                 {{interceptorName}}_MemberInfo        = MethodOf{{GetMethodOf(method)}};
					""");

				for (var i = 0; i < methods[0].attributes.Length; i++)
				{
					var attr = methods[0].attributes[i];

					sb
						.AppendLine(
							$$"""
									static SCG.Dictionary<string,object?> {{interceptorName}}_AspectArguments_{{i}} = new ()
									{
							""")
						;

					foreach (var arg in attr.NamedArguments)
					{
						string value;

						if (arg.Value.Type is IArrayTypeSymbol arrayType)
						{
							value = arg.Value.Values.Length switch
							{
								0 => $"new {arrayType.ElementType}[0]",
								_ => $"new {arg.Value.Type} {{ {arg.Value.Values.Select(v => PrintValue(v.Value)).Aggregate((v1, v2) => $"{v1}, {v2}")} }}"
							};
						}
						else
							value = PrintValue(arg.Value.Value);

						sb
							.AppendLine(
								$$"""
											["{{arg.Key}}"] = {{value}},
								""")
							;

						static string PrintValue(object? val)
						{
							return val switch
							{
								null             => "null",
								string           => $"\"{val}\"",
								char             => $"'{val}'",
								double           => $"{val}d",
								float            => $"{val}f",
								long             => $"{val}l",
								INamedTypeSymbol => $"typeof({val})",
								_                => $"{val}"
							};
						}
					}

					sb
						.AppendLine(
							"""
									};
							""")
						;
				}

				sb.AppendLine(
					$$"""
							//
							/// <summary>
							/// Intercepts {{method}}.
							/// </summary>
							//
					""");

				foreach (var (inv, _, _) in methods)
				{

					sb.AppendLine(
						$"""
								// Intercepts {inv}.
						""");

					void AppendInterceptsLocation(FileLinePositionSpan span)
					{
						sb.AppendLine(
							$"""
									[System.Runtime.CompilerServices.InterceptsLocation(@"{span.Path}", line: {span.Span.Start.Line + 1}, character: {span.Span.Start.Character + 1})]
							""");
					}

					switch (inv.Expression)
					{
						case MemberAccessExpressionSyntax { Name       : var name } : AppendInterceptsLocation(name.GetLocation().GetLineSpan()); break;
						case IdentifierNameSyntax         { Identifier : var id   } : AppendInterceptsLocation(id.  GetLocation().GetLineSpan()); break;
						default :
							sb.AppendLine(
								$"""
										#error Unknown expression type {inv.Expression.GetType()} for : {inv.Expression}
								""");
							break;
					}

					sb.AppendLine(
						"""
								//
						""");
				}

				sb
					.AppendLine(
						$$"""
								[System.Runtime.CompilerServices.CompilerGenerated]
								//[System.Diagnostics.DebuggerStepThrough]
								public static {{PrintType(method.ReturnType)}} {{interceptorName}}({{PrintArguments(method)}})
								{
						""")
					;

				GenerateMethodBody(sb, method, interceptorName, methods[0].attributes);

				sb
					.AppendLine(
						"""
								}
						""")
					.AppendLine();
			}

			TrimEnd(sb);

			sb
				.AppendLine(
					"""
						}
					}
					""");

			spc.AddSource("Interceptors.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
		}

		static void GenerateMethodBody(StringBuilder sb, IMethodSymbol method, string interceptorName, ImmutableArray<AttributeData> attributes)
		{
			GenerateAttribute(0, "\t\t\t");

			void GenerateAttribute(int idx, string indent)
			{
				var attr = attributes[idx].AttributeClass!;

				// Get aspect attribute parameters.
				//
				object? onInit       = null;
				object? onUsing      = null;
				object? onBeforeCall = null;
				object? onAfterCall  = null;
				object? onCatch      = null;
				object? onFinally    = null;

				var aa = attr.GetAttributes();

				foreach (var a in aa)
					if (a is { AttributeClass : { ContainingNamespace.Name : "Aspects", Name : "AspectAttribute" }, NamedArguments : not [] })
						foreach (var arg in a.NamedArguments)
							switch (arg.Key)
							{
								case "OnInit"      : onInit       = arg.Value.Value; break;
								case "OnUsing"     : onUsing      = arg.Value.Value; break;
								case "OnBeforeCall": onBeforeCall = arg.Value.Value; break;
								case "OnAfterCall" : onAfterCall  = arg.Value.Value; break;
								case "OnCatch"     : onCatch      = arg.Value.Value; break;
								case "OnFinally"   : onFinally    = arg.Value.Value; break;
							}

				// Generate AspectCallInfo.
				//
				sb
					.Append(indent).AppendLine($"// {attr}")
					.Append(indent).AppendLine("//")
					.Append(indent).AppendLine($"var __info__{idx} = new Aspects.InterceptCallInfo<{(method.ReturnsVoid ? "Void" : $"{method.ReturnType}")}>")
					.Append(indent).AppendLine("{")
					//.Append(indent).AppendLine($"\tReturnValue     = {(idx > 0 ? $"__info__{idx - 1}.ReturnValue" : $"default({(method.ReturnsVoid ? "Void" : $"{method.ReturnType}")})")},")
					.Append(indent).AppendLine($"\tMemberInfo      = {interceptorName}_MemberInfo,")
					.Append(indent).AppendLine($"\tAspectType      = typeof({attr}),")
					.Append(indent).AppendLine($"\tAspectArguments = {interceptorName}_AspectArguments_{idx},")
					;

				if (idx > 0)
					sb.Append(indent).AppendLine($"\tPreviousInfo    = __info__{idx - 1}");

				sb
					.Append(indent).AppendLine("};")
					.AppendLine()
					;

				// Generate OnInit.
				//
				if (onInit is not null)
					sb
						.Append(indent).AppendLine($"__info__{idx}.InterceptType = Aspects.InterceptType.OnInit;")
						.Append(indent).AppendLine($"__info__{idx} = {attr.ContainingNamespace}.{attr.Name}.{onInit}(__info__{idx});")
						.AppendLine()
						;

				// Generate OnUsing.
				//
				if (onUsing is not null)
				{
					sb
						.Append(indent).AppendLine($"using (var _ = {attr.ContainingNamespace}.{attr.Name}.{onUsing}(__info__{idx}))")
						.Append(indent).AppendLine("{")
						;
					indent += '\t';
				}

				// If OnCatch or OnFinally is defined, generate try/catch/finally block.
				//
				if (onCatch is not null || onFinally is not null)
				{
					sb.Append(indent).AppendLine("try");
					sb.Append(indent).AppendLine("{");
					indent += '\t';
				}

				// Generate OnBeforeCall.
				//
				if (onBeforeCall is not null)
				{
					sb
						.Append(indent).AppendLine($"__info__{idx}.InterceptType = Aspects.InterceptType.OnBeforeCall;")
						.Append(indent).AppendLine($"{attr.ContainingNamespace}.{attr.Name}.{onBeforeCall}(__info__{idx});")
						.AppendLine()
						.Append(indent).AppendLine($"if (__info__{idx}.InterceptResult != InterceptResult.Return)")
						.Append(indent).AppendLine("{")
						;

					indent += '\t';
				}

				// Generate next attribute...
				//
				if (idx < attributes.Length - 1)
				{
					sb.Append(indent).AppendLine("{");

					GenerateAttribute(idx + 1, indent + '\t');

					TrimEnd(sb);

					sb
						.Append(indent).AppendLine("}")
						.AppendLine()
						;
				}
				// .. or call the target method.
				//
				else
				{
					sb
						.Append(indent)
						.Append(method.ReturnsVoid ? string.Empty : $"__info__{idx}.ReturnValue = ")
						.Append(method.IsExtensionMethod || method.IsStatic? method.OriginalDefinition.ContainingType : "__this__")
						.Append('.')
						.Append(method.Name)
						.Append('(')
						;

					if (method.IsExtensionMethod)
					{
						sb.Append("__this__");

						if (method.Parameters.Length > 0)
							sb.Append(", ");
					}

					foreach (var p in method.Parameters)
						sb.Append(p.Name);

					sb
						.AppendLine(");")
						.AppendLine()
						;
				}

				// Generate OnAfterCall.
				//
				if (onAfterCall is not null)
					sb
						.Append(indent).AppendLine($"__info__{idx}.InterceptType = Aspects.InterceptType.OnAfterCall;")
						.Append(indent).AppendLine($"{attr.ContainingNamespace}.{attr.Name}.{onAfterCall}(__info__{idx});")
						.AppendLine()
						;

				// Generate OnBeforeCall end.
				//
				if (onBeforeCall is not null)
				{
					TrimEnd(sb);

					indent = indent[..^1];

					sb
						.Append(indent)
						.AppendLine("}")
						.AppendLine()
						;
				}

				// If OnCatch or OnFinally is defined, generate try/catch/finally block end.
				//
				if (onCatch is not null || onFinally is not null)
				{
					indent = indent[..^1];

					TrimEnd(sb);

					sb.AppendLine($"{indent}}}");

					// Generate OnCatch.
					//
					sb
						.Append(indent).AppendLine("catch (Exception __ex__)")
						.Append(indent).AppendLine("{")
						.Append(indent).AppendLine($"\t__info__{idx}.Exception{(onCatch is null ? null : "      ")} = __ex__;")
						;

					if (onCatch is not null)
						sb
							.Append(indent).AppendLine($"\t__info__{idx}.InterceptResult = InterceptResult.ReThrow;")
							.Append(indent).AppendLine($"\t__info__{idx}.InterceptType   = Aspects.InterceptType.OnCatch;")
							.AppendLine()
							.Append(indent).AppendLine($"\t{attr.ContainingNamespace}.{attr.Name}.{onCatch}(__info__{idx});")
							.AppendLine()
							.Append(indent).AppendLine($"\tif (__info__{idx}.InterceptResult == InterceptResult.ReThrow)")
							.Append(indent).AppendLine("\t\tthrow;")
							;
					else
						sb.Append(indent).AppendLine("\tthrow;");

					sb.Append(indent).AppendLine("}");

					// Generate OnFinally.
					//
					if (onFinally is not null)
					{
						sb
							.Append(indent).AppendLine("finally")
							.Append(indent).AppendLine("{")
							.Append(indent).AppendLine($"\t__info__{idx}.InterceptType = Aspects.InterceptType.OnFinally;")
							.Append(indent).AppendLine($"\t{attr.ContainingNamespace}.{attr.Name}.{onFinally}(__info__{idx});")
							.Append(indent).AppendLine("}")
							;
					}

					sb.AppendLine();
				}

				// Generate OnUsing.
				//
				if (onUsing is not null)
				{
					indent = indent[..^1];

					TrimEnd(sb);

					sb
						.Append(indent)
						.AppendLine("}")
						.AppendLine()
						;
				}

				// Generate return.
				//
				if (idx > 0)
					sb.Append(indent).AppendLine($"__info__{idx - 1}.ReturnValue = __info__{idx}.ReturnValue;");
				else if (!method.ReturnsVoid)
					sb.AppendLine($"\t\t\treturn __info__{idx}.ReturnValue;");

				TrimEnd(sb);
			}
		}

		static void TrimEnd(StringBuilder sb)
		{
			while (sb[^1] is '\r' or '\n')
				sb.Length--;

			sb.AppendLine();
		}

		static string PrintType(ITypeSymbol type)
		{
			return $"{type}";
		}

		static string PrintArguments(IMethodSymbol method)
		{
			var parameters = method.Parameters;
			var sb         = new StringBuilder();

			if (method.IsStatic == false)
			{
				sb
					.Append($"this {method.ReceiverType} __this__, ")
					;
			}

			foreach (var p in parameters)
			{
				sb.Append(p);
				sb.Append(", ");
			}

			if (parameters.Length != 0 || method.IsStatic == false)
				sb.Length -= 2;

			return sb.ToString();
		}

		static string GetMethodOf(IMethodSymbol method)
		{
			var sb = new StringBuilder();

			sb.Append("(() => ");

			sb
				.Append(method.IsExtensionMethod || method.IsStatic ? method.OriginalDefinition.ContainingType : $"default({method.ReceiverType})")
				.Append('.')
				.Append(method.Name)
				.Append('(')
				;

			if (method.IsExtensionMethod)
				sb.Append($"default({method.ReceiverType}), ");

			foreach (var p in method.Parameters)
				sb.Append($"default({p.Type}), ");

			while (sb[^1] is ',' or ' ')
				sb.Length--;

			sb.Append("))");

			return sb.ToString();
		}
	}
}
